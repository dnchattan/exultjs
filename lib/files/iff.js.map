{"version":3,"sources":["../src/files/iff.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,oDAAuF;AAGvF,+BAAgC;AAahC;IAAyB,uBAAM;IAqB3B,aAAY,IAAe;eACvB,kBAAM,IAAI,CAAC;IACf,CAAC;IAtBc,cAAU,GAAzB,UAA0B,IAAiB;QACvC,MAAM,CAAC;YACH,SAAS,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YAC7B,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE;YAClB,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;SAC/B,CAAC;IACN,CAAC;IACc,oBAAgB,GAA/B,UAAgC,IAAiB;QAC7C,MAAM,CAAC;YACH,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YACxB,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE;YAClB,MAAM,EAAE,IAAI,CAAC,GAAG;SACnB,CAAC;IACN,CAAC;IAWM,kBAAI,GAAX,UAAY,KAAa,EAAE,IAAY;QACnC,IAAM,GAAG,GAAkB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QAClD,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACP,MAAM,CAAC,IAAI,MAAM,CAAC,EAAE,CAAC,CAAC;QAC1B,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC3B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACpC,CAAC;IAKS,mBAAK,GAAf;QACI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACb,MAAM,IAAI,gCAAmB,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACxD,CAAC;QAED,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACxC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,KAAK,MAAM,CAAC,CAAC,CAAC;YACnC,MAAM,IAAI,sCAAyB,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QACtE,CAAC;QAaD,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;QACrB,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;YACtC,IAAM,GAAG,GAAG,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC5C,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;gBACrC,KAAK,CAAC;YACV,CAAC;YACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAG1B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;QAC3D,CAAC;IACL,CAAC;IACL,UAAC;AAAD,CAtEA,AAsEC,CAtEwB,aAAM,GAsE9B;AAtEY,kBAAG","file":"files/iff.js","sourcesContent":["import { file_read_exception, wrong_file_type_exception } from '../include/exceptions';\r\nimport { char, IReference, uint32 } from '../include/types';\r\nimport { IDataSource } from './databuf';\r\nimport { U7File } from './file';\r\nimport { IFileSpec } from './object';\r\n\r\ninterface IHeader {\r\n    formMagic: string; // length:4\r\n    size: uint32;\r\n    dataType: string; // length:4\r\n}\r\n\r\ninterface IIFFReference extends IReference {\r\n    name: string;\r\n}\r\n\r\nexport class IFF extends U7File {\r\n    private static readHeader(data: IDataSource): IHeader {\r\n        return {\r\n            formMagic: data.readString(4),\r\n            size: data.read4(),\r\n            dataType: data.readString(4),\r\n        };\r\n    }\r\n    private static readObjectHeader(data: IDataSource): IIFFReference {\r\n        return {\r\n            name: data.readString(4),\r\n            size: data.read4(),\r\n            offset: data.pos,\r\n        };\r\n    }\r\n\r\n    public count: number;\r\n    public type: 'IFF';\r\n    private header: IHeader;\r\n    private objectList: IIFFReference[];\r\n\r\n    constructor(spec: IFileSpec) {\r\n        super(spec);\r\n    }\r\n\r\n    public read(index: number, size: number): Buffer {\r\n        const ref: IIFFReference = this.objectList[index];\r\n        if (!ref) {\r\n            return new Buffer('');\r\n        }\r\n        this.data.seek(ref.offset);\r\n        return this.data.read(ref.size);\r\n    }\r\n\r\n    /**\r\n     *  Reads the header from an IFF and builds an object index.\r\n     */\r\n    protected index(): void {\r\n        if (!this.data) {\r\n            throw new file_read_exception(this.identifier.name);\r\n        }\r\n\r\n        this.header = IFF.readHeader(this.data);\r\n        if (this.header.formMagic !== 'FORM') {\r\n            throw new wrong_file_type_exception(this.identifier.name, 'FLEX');\r\n        }\r\n\r\n        /*\r\n        -the objects entries\r\n            entry   = type, size, object, [even]\r\n            type    = 4 chars representing the type of this object\r\n            size    = reversed longint (size of the entry excluding the first 8 bytes)\r\n            even    = 1 byte (set to 0) present only to get an even number of bytes\r\n            (the objects found in U7 IFF files have the following format:)\r\n            object  = name, data\r\n            name    = 8 chars (filled with 0s)\r\n            data    = the data of the object\r\n        */\r\n        this.objectList = [];\r\n        while (this.data.pos < this.header.size) {\r\n            const ref = IFF.readObjectHeader(this.data);\r\n            if (ref.size === 0 || ref.offset === 0) {\r\n                break;\r\n            }\r\n            this.objectList.push(ref);\r\n    \t\t// Objects are word-aligned in IFF files.\r\n            // tslint:disable-next-line:no-bitwise\r\n            this.data.seek(ref.offset + ref.size + (ref.size & 1));\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":"/source/"}